// Cycle Monitor, Copyright (C) 2015  M.B.Grieve
// This file is part of the Cycle Monitor example application.
//
// Cycle Monitor is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Cycle Monitor is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with City Monitor.  If not, see <http://www.gnu.org/licenses/>.
//
// Contact: moray.grieve@me.com

package com.jtech.alert;
using com.jtech.config.DBKey;
using com.jtech.config.CreateUpperBoundaryAlert;
using com.jtech.config.CreateLowerBoundaryAlert;
using com.jtech.config.CreateRateThresholdAlert;
using com.jtech.source.StationUpdate;

monitor AlertManager {
	IAlertManager this;
	com.jtech.util.KeyedDataViewHelper dvHelper;
	dictionary < DBKey, sequence<IAlertStrategy> > strategies;

	action onload {
		log "Alert manager loaded" at INFO;

		//register the alert dataview
		dvHelper.register((new Alert).iface());

		//initialise the interface
		this.addAlert := addAlert;
		this.clearAlert := clearAlert;

		//handle create requests
		createUpperBoundary();
		createLowerBoundary();
		createRateThreshold();
		
		//pass updates to the relevant strategies
		StationUpdate stationUpdate;
		on all StationUpdate():stationUpdate {
			DBKey key := DBKey(stationUpdate.city, stationUpdate.id);
			if (strategies.hasKey(key)) then {
				IAlertStrategy strategy; for strategy in strategies[key] {
					strategy.check(stationUpdate);
				}
			}
		}
	}

	action createUpperBoundary() {
		CreateUpperBoundaryAlert uba;
		on all CreateUpperBoundaryAlert():uba {
			DBKey key := DBKey(uba.city, uba.id);
			if not strategies.hasKey(key) then {
				strategies.add(key, new sequence<IAlertStrategy> );
			}
			strategies[key].append( (new UpperBoundary).init(uba.id, uba.city, uba.threshold, this) );
		}
	}

	action createLowerBoundary() {
		CreateLowerBoundaryAlert lba;
		on all CreateLowerBoundaryAlert():lba {
			DBKey key := DBKey(lba.city, lba.id);
			if not strategies.hasKey(key) then {
				strategies.add(key, new sequence<IAlertStrategy> );
			}
			strategies[key].append( (new LowerBoundary).init(lba.id, lba.city, lba.threshold, this) );
		}
	}
	
	action createRateThreshold() {
		CreateRateThresholdAlert rta;
		on all CreateRateThresholdAlert():rta {
			DBKey key := DBKey(rta.city, rta.id);
			if not strategies.hasKey(key) then {
				strategies.add(key, new sequence<IAlertStrategy> );
			}
			strategies[key].append( (new RateThreshold).init(rta.id, rta.city, rta.threshold, rta.duration, this) );
		}
	}

	action addAlert(StationUpdate update, string type, string message, string color) {
		log "Adding alert for "+update.id.toString()+","+update.city+","+type at INFO;
		dvHelper.add((Alert(update.city, update.id, update.name, update.lat, update.lng, 
		                    update.ratio, update.docked, update.empty, update.timestamp, type, message, color)).iface());
	}
	
	action clearAlert(string city, integer id, string type) {
		log "Removing alert for"+id.toString()+","+city+","+type at INFO;
		dvHelper.remove(((new Alert).init(city,id,type)).iface());
	}
}