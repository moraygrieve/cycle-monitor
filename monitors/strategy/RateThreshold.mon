package com.jtech.alert;
using com.apama.aggregates.first;
using com.apama.aggregates.last;
using com.jtech.source.StationUpdate;

event Result { float first; float last; }
event Data { float ratio;  }

event RateThreshold {
	constant string  TYPE :="RATE_THRESHOLD";
	constant string  COLOR:="yellow";

	AlertStrategy base;
	float _threshold;
	float _duration;
	StationUpdate _current;

	action init(integer id, string city, float threshold, float duration, IAlertManager manager) returns IAlertStrategy {    
		_threshold := threshold;
		_duration := duration;

		IAlertStrategy this := base.init(id, city, TYPE, COLOR, manager);
		return this;
	}

	//implementation of required actions
	action check(StationUpdate update) {
		_current := update;
		route Data(update.ratio);
	}

	action streamListener() {
		Result result;
		from u in all Data() within _duration
		  select Result(first(u.ratio),last(u.ratio)):result {
			float change:=0.0;
			if ( not (result.first=result.last or result.first.isNaN() or result.last.isNaN()) ) then {
				change := ( (result.last-result.first)/(result.first) ).abs(); 
				checkForAlert(change);
			}
		}
	} 

	action checkForAlert(float change) {
		if (not base.getAlerted() and change > _threshold) then {
			base.alert(_current, "Change of " +change.formatFixed(2) + " exceeds limit " + _threshold.toString());
		}
		else if (base.getAlerted() and change <= _threshold) then {
			base.clear();
		}
	}
}
