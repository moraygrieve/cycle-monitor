// Cycle Monitor, Copyright (C) 2015  M.B.Grieve
// This file is part of the Cycle Monitor example application.
//
// Cycle Monitor is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Cycle Monitor is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with City Monitor.  If not, see <http://www.gnu.org/licenses/>.
//
// Contact: moray.grieve@me.com

package com.jtech.alert;
using com.apama.aggregates.first;
using com.apama.aggregates.last;
using com.jtech.source.StationUpdate;

event Result { float first; float last; }
event Data { string city; integer id; float ratio;  }

event RateThreshold {
	constant string  TYPE :="RATE_THRESHOLD";
	constant string  COLOR:="yellow";

	AlertStrategy base;
	float _threshold;
	float _duration;
	StationUpdate _current;

	action init(integer id, string city, float threshold, float duration, IAlertManager manager) returns IAlertStrategy {    
		_threshold := threshold;
		_duration := duration;

		IAlertStrategy this := base.init(id, city, TYPE, COLOR, manager);
		return this;
	}

	//implementation of required actions
	action check(StationUpdate update) {
		_current := update;
		route Data(base._city, base._id, update.ratio);
	}

	action streamListener() {
		Result result;
		from u in all Data(city=base._city, id=base._id) within _duration
		  select Result(first(u.ratio),last(u.ratio)):result {
			float change:=0.0;
			if ( not (result.first=result.last or result.first.isNaN() or result.last.isNaN()) ) then {
				change := ( (result.last-result.first)/(result.first) ).abs(); 
				checkForAlert(change);
			}
			log base._prefix+"change="+change.toString()+",result="+result.toString()+",last="+_current.toString() at DEBUG;
		}
	} 

	action checkForAlert(float change) {
		if (not base.getAlerted() and change > _threshold) then {
			base.alert(_current, "Change of " +change.formatFixed(2) + " exceeds limit " + _threshold.toString());
		}
		else if (base.getAlerted() and change <= _threshold) then {
			base.clear();
		}
	}
}
